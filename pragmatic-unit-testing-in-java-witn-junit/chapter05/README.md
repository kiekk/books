## 5장 좋은 테스트의 FIRST 속성

>테스트 또한 여러분이 작성하고 유지 보수해야 하는 또 다른 코드입니다.
> 
> 테스트에 다음 문제점이 있다면 여러분 시간과 수면은 부족해질 것입니다.

- 테스트를 사용하는 사람에게 어떤 정보도 주지 못하는 테스트
- 산발적으로 실패하는 테스트
- 어떤 가치도 증명하지 못하는 테스트
- 실행하는 데 오래 걸리는 테스트
- 코드를 충분히 커버하지 못하는 테스트
- 구현과 강하게 결합되어 있는 테스트, 따라서 작은 변화에도 다수의 테스트가 깨집니다.
- 수많은 설정 고리로 점프하는 난해한 테스트

### FIRST: 좋은 테스트 조건

- 다음 FIRST 원리를 따르면 단위 테스트 작성자가 흔히 빠지는 위험을 피할 수 있습니다.
  - [F]ast: 빠른
  - [I]solated: 고립된
  - [R]epeatable: 반복 가능한
  - [S]elf-Validating: 자체 검증하는
  - [T]imely: 적시의
```markdown
FIRST 단어는 그 자체로 단위 테스트 맥락에서 상당한 의미가 있습니다.
...
일반적인 단위 테스트(POUT, Plain Ol' Unit Testing)와 TDD 차이점은 TDD에서는 테스트를 먼저 작성한다는 것입니다.
...
테스트를 먼저 작성하든 이후에 작성하든 FIRST 원리를 고수하면 어떤 것이든 잘해 나갈 수 있을 것입니다.
```

| **전략**                          | **이름**                  | **설명**                   |
|---------------------------------|-------------------------|--------------------------|
| 🧪 TFD (Test First Development) | 테스트 먼저 작성 → 코드를 맞춰 구현   | 도메인/로직 중심에 적합            |
| 🏗 TLD (Test Last Development)  | 코드를 먼저 작성 → 테스트는 나중에 작성 | API/계층 설계가 먼저 필요한 상황에 적합 |

### 5.2 [F]IRST: 빠르다
```markdown
단위 테스트를 하루에 서너 번 실행하기도 버겁다면 무언가 잘못된 방향으로 나아가고 있는 것입니다.
...
테스트를 빠르게 유지하세요!
설계를 깨끗하게 하면 빠르게 유지할 수 있습니다.
가장 먼저 느린 테스트에 대한 의존성을 줄이세요.
모든 테스트 코드가 데이터베이스를 호출한다면 전체 테스트 또한 느릴 것입니다.
...
테스트 코드는 빠르게 동작하며, 느린 것에 의존하는 코드를 최소화한다면 작성하기도 쉬워집니다.
이러한 의존성을 최소화하는 것 역시 좋은 설계의 목표입니다.
다시 한 번 말하지만, 코드를 클린 객체 지향 설계 개념과 맞출수록 단위 테스트 작성도 쉬워집니다.
```

### 5.3 F[I]RST: 고립시킨다
```markdown
좋은 단위 테스트는 검증하려는 작은 양의 코드에 집중합니다.
이것은 우리가 단위라고 말하는 정의와 부합합니다.
...
테스트 대상 코드는 데이터베이스를 읽는 다른 코드와 상호 작용할 수도 있습니다.
데이터 의존성은 많은 문제를 만듭니다.
궁극적으로 데이터베이스에 의존해야 하는 테스트는 데이터베이스가 올바른 데이터를 가지고 있는지 확인해야 합니다.
...
좋은 단위 테스트는 다른 단위 테스트에 의존하지 않습니다(혹은 같은 메서드에 있는 테스트 케이스).
아마도 여러 테스트가 값비싸게 생성된 데이터를 재사용하는 방식으로 테스트 순서를 조작하여 전체 테스트의 실행 속도를 높이려고 할 수도 있습니다.
하지만 이렇게 하면 의존성의 악순환만 동시에 발생합니다.
일이 잘못되면 테스트가 실패했을 때 이러한 일을 만들어 내는 앞선 이벤트의 긴 사슬을 따라 무엇이 원인인지 알아내느라 긴 시간을 소모할 수도 있습니다.
따라서 테스트 코드는 어떤 순서나 시간에 관계없이 실행할 수 있어야 합니다.
각 테스트가 작은 양의 동작에만 집중하면 테스트 코드를 집중적이고 독립적으로 유지하기 쉬워집니다.
...
객체 지향 클래스 설계의 단일 책임 원칙(SRP)에 따르면 클래스는 작고 단일한 목적을 가져야 합니다.
좀 더 구체적으로 SRP는 클래스를 변경해야 할 이유가 하나만 있어야 한다고 말합니다.
...
테스트 메서드가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것도 고려해 보세요.
...
테스트 코드를 스위스처럼 만들어야 합니다.
고립시켜 시계처럼 동작하게 하세요.
```

### 5.4 FI[R]ST: 좋은 테스트는 반복 가능해야 한다.
```markdown
테스트는 뜬금없이 나오면 안 됩니다.
...
테스트 설계에서 여러분 역할 중 일부는 테스트 결과가 매번 어떻게 나와야 하는지에 대해 설명하는 단언을 제공하는 것입니다.
반복 가능한 테스트는 실행할 때마다 결과가 같아야 합니다.
따라서 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리시켜야 합니다.
하지만 시스템은 불가피하게 통제할 수 없는 요소와 상호 작용해야 할 것입니다.
예를 들어 현재 시간을 다루어야 한다면 테스트 코드는 반복 가능한 테스트를 힘들게 하는 불편한 요소를 어떻게든 다루게 됩니다.
이때는 테스트 대상 코드의 나머지를 격리하고 시간 변화에 독립성을 유지하는 방법으로 목 객체를 사용할 수 있습니다.
...
산발적으로 실패하는 테스트는 골칫거리입니다.
...
하지만 더 자주 간헐적으로 실패하는 테스트는 양치기 소년(cry wolf)이 됩니다.
...
반복성이 없다면 가장 최악의 순간에 놀랄 수도 있습니다.
설상가상으로 이러한 놀라운 상황이 가짜일 수도 있습니다.
즉, 진짜 버그가 아니라 단지 테스트 문제인 것이죠.
유령 문제를 쫒아서 시간을 낭비할 필요가 없습니다.
각 테스트는 항상 동일한 결과를 만들어 내야 합니다.
```

### 5.5 FIR[S]T: 스스로 검증 가능하다
```markdown
테스트는 기대하는 것이 무엇인지 단언하지 않으면 테스트가 아닙니다.
테스트는 스스로 검증 가능할 뿐만 아니라 준비할 수도 있어야 합니다.
```

### 5.6 FIRS[T]: 적시에 사용한다
```markdown
사실상 언제라도 단위 테스트를 작성할 수도 있습니다.
...
가능하면 적절한 순간에 단위 테스트에 집중하는 것이 낫습니다.
단위 테스트는 좋은 습관입니다.
...
단위 테스트를 더 많이 할수록 테스트 대상 코드가 줄어듭니다.
그러면 먼저 단위 테스트 작성이 쉬워집니다.
```
