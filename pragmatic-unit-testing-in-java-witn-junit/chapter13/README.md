## 13장 까다로운 테스트

### 13.1 멀티스레드 코드 테스트

#### 13.1.1 단순하고 똑똑하게 유지

```markdown
멀티스레드 코드를 테스트할 때는 다음 주요 주제를 따르세요.
- 스레드 통제와 애플리케이션 코드 사이의 중첩을 최소화하세요:
    스레드 없이 다량의 애플리케이션 코드를 단위 테스트할 수 있도록 설계를 변경하세요.
    남은 작은 코드에 대해 스레드에 집중적인 테스트를 작성하세요.
- 다른 사람의 작업을 믿으세요:
    자바 5에는 더그 리아(Doug Lea)의 훌륭한 동시성 유틸리티 클래스(java.util.concurrent 패키지에 있음)가 들어 있고,
    그것은 이미 2004년에 나온 자바 5 이래로 오랜 시간 충분히 검증받았습니다.
    예를 들어 생산자(producer)/소비자(consumer) 문제를 직접 코딩하지 말고(이 경우 잘못되기 쉬움) 똑똑한 다른 사람들이 직접 써 보며 유용성을 입증한 BlockingQueue 클래스를 사용하세요.
```

### 13.2 데이터베이스 테스트

#### 13.2.2 데이터 문제

```markdown
(테스트 목적에서 H2 같은 인메모리 데이터베이스로 프로덕션 데이터베이스를 모사하고 싶을 수도 있습니다. 속도야 빠르겠지만 그 밖의 좋은 운도 필요합니다.
이 경우 인메모리 DB와 프로덕션 RDBMS의 미묘한 차이 때문에 벌어질 문제점들을 상상해 보세요.)
진짜 데이터베이스와 상호 작용하는 통합 테스트를 작성할 때 데이터베이스의 데이터와 그것을 어떻게 가져올지는 매우 중요한 고려 사항입니다.
데이터베이스가 기대한 대로 질의(query) 결과가 나온다고 증명하려면 먼저 적절한 데이터를 넣거나 이미 이러한 데이터가 데이터베이스에 있다고 가정해야 합니다.
데이터가 이미 데이터베이스에 있다고 가정하는 것은 고통스러운 요리법입니다.
시간이 지나면서 데이터는 여러분도 모르게 변질될 것이고 테스트도 망가집니다.
테스트 코드와 데이터를 분리시키면 특정 테스트가 왜 통과하거나 실패하는지 그 이유를 이해하기가 더욱 어려워집니다.
테스트 관점에서 데이터 의미는 그것을 모두 데이터베이스에 부어 넣는 순간 사라집니다.
테스트 안에서 데이터를 생성하고 관리하세요.
...
머신에 있는 데이터베이스라면 가장 간단한 경로는 테스트마다 깨끗한 데이터베이스로 시작하는 것입니다
(혹은 적절한 참조 데이터를 포함한 기존에 생성된 데이터베이스 인스턴스도 좋습니다).
매 테스트는 그다음 자기가 쓸 데이터를 추가하거나 그것으로 작업합니다.
이렇게 하면 테스트 간 의존성 문제를 최소화할 수 있습니다.
테스트 간 의존성 문제는 다른 테스트에서 남아 있던 데이터 때문에 어떤 테스트가 망가지는 것을 의미합니다(디버깅하기에도 골치 아픕니다).
```
