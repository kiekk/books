## 4장 테스트 조직

### 4.1 AAA로 테스트 일관성 유지

```markdown
- 준비(Arrange):
  테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인합니다.
  객체들을 생성하거나 이것과 의사소통하거나 다른 API를 호출하는 것 등입니다.
  드물지만 시스템이 우리가 필요한 상태로 있다면 준비 상태를 생략하기도 합니다.

- 실행(Act):
  테스트 코드를 실행합니다.
  보통은 단일 메서드를 호출합니다.

- 단언(Assert):
  실행한 코드가 기대한 대로 동작하는지 확인합니다.
  실행한 코드의 반환값 혹은 그 외 필요한 객체들의 새로운 상태를 검사합니다.
  또 테스트한 코드와 다른 객체들 사이의 의사소통을 검사하기도 합니다.

때에 따라 네 번째 단계가 필요하빈다.

- 사후(After):
  테스트를 실행할 때 어떤 자원을 할당했다면 잘 정리(clean up) 되었는지 확인해야 합니다.
```

### 4.3 테스트와 프로덕션 코드의 관계

```markdown
JUnit 테스트는 검증 대상인 프로덕션 코드와 같은 프로젝트에 위치할 수 있습니다.
하지만 테스트는 주어진 프로젝트 안에서 프로덕션 코드와 분리해야 합니다.
프로덕션 코드(테스트 대상으로 테슽 대상 시스템(SUT, System Under Test) 이라고도 함)를 배포할 것이지만 테스트는 일반적으로 그 뒤에 존재합니다.
```

#### 4.3.1 테스트와 프로덕션 코드 분리

```markdown
- 테스트를 프로덕션 코드와 같은 디렉터리 및 패키지에 넣기
  구현하기 쉽지만 어느 누구도 실제 시스템에 이렇게 하지 않습니다.
  이 정책을 쓰면 실제 배포할 때 테스트 코드를 걷어 내는 스크립트가 필요합니다.
  클래스 이름으로 구별하거나 테스트 클래스 여부를 식별할 수 있는 리플렉션 코드를 작성해야 합니다.
  테스트를 같은 디렉터리에 유지하면 디렉터리 목록에서 뒤져야 하는 파일 개수도 늘어납니다.

- 테스트를 별도 디렉터리로 분리하지만 프로덕션 코드와 같은 패키지에 넣기 ✅
  대부분의 회사에서 이것을 선택합니다.
  ...
  test 디렉터리의 구조가 src 디렉터리를 반영하기 때문에 각 테스트는 검증하고자 하는 대상 클래스와 동일한 패키지를 가집니다.
  테스트 클래스는 패키지 수준의 접근 권한을 가집니다.
```

#### 4.3.2 내부 데이터 노출 vs 내부 동작 노출

```markdown
어떤 개발자들은 테스트를 작성할 때 프로덕션 코드의 공개 인터페이스만 사용해야 한다고 믿습니다.
공개가 아닌 메서드를 테스트 코드에서 호출하면 정보 은닉(information hiding) 원칙을 위배한다고 생각합니다.
한 가지 시사점은 다음과 같습니다.
비공개 코드를 호출하는 테스트는 그 자체로 구현 세부 사항과 결속하게 됩니다.
이러한 세부 사항이 변경되면 기술적으로 공개적인 행동이 그대로라고 해도 테스트는 깨질 수 있습니다.
...
테스트가 프로덕션 코드와 같은 패키지에 있다면 게터 메서드를 호출하여 패키지 수준의 접근 권한을 얻을 수 있습니다.
외부 세상으로 필드를 공개하지 않을수록 좀 더 편안해집니다.
테스트를 위해 내부 데이터를 노출하는 것은 테스트와 프로덕션 코드 사이에 과도한 결합을 초래합니다.
내부 동작을 노출하는 것은 다른 문제입니다.
...
내부 행위를 테스트하려는 충동이 든다면 설계에 문제가 있는 것입니다.
묻혀 있는 수많은 흥미로운 행동은 거의 단일 책임 원칙(SRP, Single Responsibility Principle)을 어기게 됩니다.
SRP는 어떤 클래스가 작고 단일 목적을 가져야 함을 의미하며, 가장 좋은 해결책은 흥미로운 private 메서드를 추출하여 다른 클래스로 이동하는 것입니다.
그렇게 하면 그 클래스의 유용한 public 메서드가 됩니다.
```

### 4.4 집중적인 단일 목적 테스트의 가치

`Tip: 다수의 케이스를 별도의 JUnit 테스트 메서드로 분리하세요. 각각에는 검증하는 동작을 표현하는 이름을 붙이세요.`

```markdown
테스트를 분리하면 다음과 같이 할 수 있습니다.

- 단언이 실패했을 때 실패한 테스트 이름이 표시되기 때문에 어느 동작에서 문제가 있는지 빠르게 파악할 수 있습니다.
- 실패한 테스트를 해독하는 데 필요한 시간을 줄일 수 있습니다.
  JUnit은 각 테스트를 별도의 인스턴스로 실행하기 때문입니다. 따라서 현재 실패한 테스트에 대해 다른 테스트의 영향을 제거할 수 있습니다.
- 모든 케이스가 실행되었음을 보장할 수 있습니다. 단언이 실패하면 현재 테스트 메서드는 중단합니다.
  단언 실패는 java.lang.AssertionError를 던지기 때문입니다. (JUnit은 이것을 잡아 테스트를 실패로 표시합니다.)
  단언 실패 이후의 테스트 케이스는 실행되지 않습니다.
```

### 4.5 문서로서의 테스트

`단위 테스트는 우리가 만드는 클래스에 대한 지속적이고 믿을 수 있는 문서 역할을 해야 합니다.`

#### 4.5.1 일관성 있는 이름으로 테스트 문서화

```markdown
좀 더 작은 테스트로 이동할수록 각각은 분명한 행동에 집중합니다.
또 각 테스트 이름에 더 많은 의미를 부여할 수 있습니다.
...
어떤 형식이든 일관성을 유지하는 것이 중요합니다.
주요 목표는 테스트 코드를 다른 사람에게 의미 있게 만드는 것입니다.
```

#### 4.5.2 테스트를 의미 있게 만들기

`Tip: 테스트 이름과 코드를 재작업하여 부가적으로 주석을 넣지 않고도 스토리를 알 수 있도록 만드세요.`

```markdown
- 지역 변수 이름 개선하기
- 의미 있는 상수 도입하기
- 햄크레스트 단언 사용하기
- 커다란 테스트를 작게 나누어 집중적인 테스트 만들기
- 테스트 군더더기들을 도우미 메서드와 @Before 메서드로 이동하기
```

### 4.6 @Before와 @After (공통 초기화와 정리) 더 알기

```markdown
때때로 셋업(setup) 메서드라고도 합니다. (또는 테스트 훅 메서드라고도 합니다.)
...
주의하세요. 다수의 @Before 메서드가 있을 때 JUnit은 어떤 실행 순서를 보장하지 않습니다.
...
일정한 순서가 필요하다면 단일 @Before 메서드로 결합하여 순서대로 실행되도록 해야 합니다.
```
