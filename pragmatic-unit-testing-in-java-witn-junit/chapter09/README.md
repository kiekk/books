## 9장 더 큰 설계 문제

### 9.1 Profile 클래스와 SRP

```markdown
(SRP는 다음 'SOLID 클래스의 설계 원칙'에 있는 다섯 가지 중요한 클래스 설계 원칙 중 하나입니다).
어떤 클래스에 대해 단일 책임을 강조하면 변경으로 인한 리스크는 줄어듭니다.
클래스에 더 많은 책임이 존재할수록 클래스에 있는 코드를 변경할 때 기존의 다른 동작들을 깨기 쉽습니다.
더 작고 집중화된 클래스는 다른 맥락에서도 가치를 제공할 수 있습니다.
바로 재활용입니다.
반대로 다수의 책임을 가진 매우 큰 클래스는 다른 맥락에서 사용되기 어렵습니다.
```

```markdown
- SOLID 클래스의 설계 원칙

1990년대 중반에 로버트 마틴(Robert C. Martin)은 객체 지향 클래스 설계에 관한 다섯 가지 원칙을 모아서 유지 보수 가능한 객체 지향 시스템을 제작하는 최상의 지침을 제공했습니다.
마이클 패더스(Michael Feathers)는 2000년 초, 이 원칙들에 SOLID라는 약어를 붙였습니다.

- 단일 책임 원칙([S]RP): 클래스는 변경할 때 한 가지 이유만 있어야 합니다. 클래스는 작고 단일 목적을 추구합니다.
- 개방 폐쇄 원칙([O]CP): 클래스는 확장에 열려 있고 변경에는 닫혀 있어야 합니다. 기존 클래스의 변경을 최소화해야 합니다.
- 리스코프 치환 원칙([L]SP): 하위 타입은 반드시 상위 타입을 대체할 수 있어야 합니다. 클라이언트 입장에서 오버라이딩한 메서드가 기능성을 깨면 안 됩니다.
- 인터페이스 분리 원칙([I]SP): 클라이언트는 필요하지 않는 메서드에 의존하면 안 됩니다. 커다란 인터페이스를 다수의 작은 인터페이스로 분할하세요.
- 의존성 역전 원칙([D]IP): 고수준 모듈은 저수준 모듈을 의존해서는 안 됩니다. 둘 다 추상 클래스에 의존해야 합니다. 추상 클래스는 구체 클래스에 의존해서는 안 됩니다. 구체 클래스는 추상 클래스에 의존해야 합니다.
```

### 9.3 명령-질의 분리

```markdown
어떤 값을 반환하고 부작용을 발생시키는 (시스템에 있는 어떤 클래스 혹은 엔터티의 상태 변경) 메서드는 명령-질의 분리(command-query separation) 원칙을 위반합니다.
이 원칙에 따르면 어떤 메서드는 명령을 실행(부작용을 생성하는 어떤 작업을 함)하거나 질의에 대답(어떤 값 반환)할 수 있으며, 두 작업을 모두 하면 안 됩니다.
일부 경우에 명령-질의 분리 원칙은 클라이언트 코드에 잠재적인 고통을 줄 수 있습니다.
질의 메서드가 객체 상태를 바꾸면 그 메서드를 두 번 호출하는 것(어떤 이유에서 같은 질문을 두 번 하는 것)이 불가능할 수도 있습니다.
혹은 두 번째 호출하면 바라지 않는 방향으로 객체 상태가 변질될 수도 있습니다.
```

### 9.4 단위 테스트의 유지 보수 비용

#### 9.4.1 자신을 보호하는 방법

```markdown
코드 중복은 가장 큰 설계 문제입니다.
테스트 자체의 과점에서 여러 테스트에 걸친 코드 중복은 두 가지 문제가 있습니다.
첫째, 테스트를 따르기가 어려워집니다.
...
둘째, 작은 코드 조각들을 단일 메서드로 추출하 그 코드 조각들을 변경해야 할 때 미치는 영향을 최소화할 수 있습니다.
...
단위 테스트를 설정하는 데 코드가 몇 줄 혹은 수십 줄 필요하다면 그것은 시스템 설계에 문제가 있다는 것입니다.
```
