## 3장. 단위 테스트 구조

### 3.1 단위 테스트를 구성하는 방법

#### 3.1.1 AAA 패턴 사용

```markdown
AAA 패턴은 각 테스트를 준비, 실행, 검증이라는 세 부분으로 나눌 수 있다. (이 패턴을 '3A 패턴'이라고도 한다.)
...
AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다.
이러한 일관성이 이 패턴의 가장 큰 장점 중 하나다.
일단 익숙해지면 모든 테스트를 쉽게 읽을 수 있고 이해할 수 있다.
결국 전체 테스트 스위트의 유지 보수 비용이 줄어든다.
구조는 다음과 같다.

- 준비 구절에서는 테스트 대상 시스템(SUT, System Under Test)과 해당 의존성을 원하는 상태로 만든다.
- 실행 구절에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 (출력이 있으면) 출력 값을 캡처한다.
- 검증 구절에서는 결과를 검증한다. 결과는 반환 값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.
```

#### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기

```markdown
검증 구절(어쩌면 준비 구절)로 구분된 여러 개의 실행 구절을 보면, 여러 개의 동작 단위를 검증하는 테스트를 뜻한다.
...
이러한 테스트는 더 이상 단위 테스트가 아니라 통합 테스트다.
이러한 테스트 구조는 피하는 것이 좋다.
실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고, 간단하고, 빠르며, 이해하기 쉽다.
일련의 실행과 검증이 포함된 테스트를 보면 리팩터링하라.
각 동작을 고유의 테스트로 도출하라.
```

#### 3.1.3 테스트 내 if 문 피하기

```markdown
준비, 실행, 검증 구절이 여러 차례 나타나는 것과 비슷하게, if 문이 있는 단위 테스트를 만날 수 있다.
이것도 안티 패턴이다.
단위 테스트든 통합 테스트든 테스트는 분기가 없는 간단한 일련의 단계여야 한다.
if 문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다.
그러므로 이러한 테스트는 반드시 여러 테스트로 나눠야 한다.
...
if 문은 테스트를 읽고 이해하는 것을 더 어렵게 만든다.
```

#### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가

```markdown
검증 구절이 너무 커지는 것은 경계해야 한다.
...
SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버(equals(), ==)를 정의하는 것이 좋다.
그러면 단일 검증문으로 객체를 기대값과 비교할 수 있다.
```

### 3.3 테스트 간 테스트 픽스처 재사용

```markdown
테스트에서 언제 어떻게 코드를 재사용하는지 아는 것이 중요하다.
준비 구절에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화하기 좋은 방법이고, 이 절에서는 올바른 방법을 알아본다.
...
재사용하는 방법은 두 가지가 있는데, 그중 하나만 유용하다. 다른 하나는 유지비를 증가시킨다.

[테스트 픽스처]

- 테스트 픽스처라는 단어는 다음과 같이 두 가지 공통된 의미가 있다.
    1. 테스트 픽스처는 테스트 실행 대상 객체다. 이 객체는 정규 의존성, 즉 SUT로 전달된느 인수다.
       데이터베이스에 있는 데이터나 하드 디스크의 파일일 수 있다.
       이러한 객체는 각 테스트 실행 전에 알려진 고정 상태로 유지하기 떄문에 동일한 결과를 생성한다.
       따라서 픽스처라는 단어가 나왔다.
    2. 다른 정의는 NUnit 테스트 프레임워크에서 비롯된다.
       NUnit에서 [TestFixture]는 테스트가 포함된 클래스를 표시하는 특성이다.

테스트 픽스처를 재사용하는 첫 번째(올바르지 않은) 방법은 다음과 같이 테스트 생성자(또는 NUnit을 사용하는 경우 [Setup] 특성으로 표시된 메서드)에서 픽스처를 초기화하는 것이다.
...
이 기법은 두 가지 중요한 단점이 있다.
- 테스트 간 결합도가 높아진다.
- 테스트 가독성이 떨어진다.
```

#### 3.3.1 테스트 간의 높은 결합도는 안티 패턴이다.

```markdown
테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다.
...
여기서는 테스트의 독립적인 수정이지, 독립적인 실행이 아니다.
둘 다 잘 설계된 테스트의 중요한 특성이다.
이 지침을 따르려면 테스트 클래스에 공유 상태를 두지 말아야 한다.
```

#### 3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용

```markdown
준비 코드를 생성자로 추출할 때의 또 다른 단점은 테스트 가독성을 떨어뜨리는 것이다.
테스트만 보고는 더 이상 전체 그림을 볼 수 없다.
테스트 메서드가 무엇을 하는지 이해하려면 클래스의 다른 부분도 봐야 한다.
```

#### 3.3.3 더 나은 테스트 픽스처 재사용법

```markdown
두 번째 방법은 다음 예제와 같이 테스트 클래스에 비공개 팩토리 메서드를 두는 것이다.
```
```java
public class CustomerTests {
    public void Purchase_succeeds_when_enough_inventory() {
        Store store = CreateStoreWithInventory(Product.Shampoo, 10);
        Customer sut = CreateCustomer();
        bool success = sut.Purchase(store, Product.Shampoo, 5);
        Assert.True(success);
        Assert.Equal(5, store.GetInventory(Product.Shampoo));
    }
    
    private static Customer CreateCustomer() {
        return new Customer();
    }
}
```
```markdown
공통 초기화 코드를 비공개 팩토리 메서드로 추출해 테스트 코드를 짧게 하면서, 동시에 테스트 진행 상황에 대한 전체 맥락을 유지할 수 있다.
...
팩토리 메서드 내부를 알아볼 필요가 없기 때문에 가독성이 좋다.
다른 테스트에서도 이 메서드를 사용할 수 있기 때문에 재사용도 가능하다.
```

### 3.4 단위 테스트 명명법

```markdown
테스트에 표현력이 있는 이름을 붙이는 것이 중요하다.
올바른 명칭은 테스트가 검증하는 내용과 기본 시스템의 동작을 이해하는 데 도움이 된다.
...
가장 유명하지만 가장 도움이 되지 않는 방법 중 하나가 다음과 같은 관습이다.
- [테스트 대상 메서드]_[시나리오]_[예상 결과]

- 테스트 대상 메서드: 테스트 중인 메서드의 이름
- 시나리오: 메서드를 테스트하는 조건
- 예상 결과: 현재 시나리오에서 테스트 대상 메서드에 기대하는 것

동작 대신 구현 세부 사항에 집중하게끔 부추기기 때문에 분명히 도움이 되지 않는다.
간단하고 쉬운 영어 구문이 훨씬 효과적이며, 엄격한 명명 구조에 얽매이지 않고 표현력이 뛰어나다.
```
